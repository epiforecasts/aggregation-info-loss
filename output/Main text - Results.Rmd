---
title: "Characterising information loss due to aggregating epidemic model outputs"
output: html_document
---

```{r set-up, include=FALSE}
# Set up Rmarkdown and workspace -----
library(here)
library(dplyr)
library(tidyr)
library(purrr)
library(scoringutils)
library(ggplot2)
library(patchwork)
knitr::opts_chunk$set(eval = TRUE, echo = FALSE,
                      message = FALSE, warning = FALSE,
                      eval.after = "fig.cap")
options(digits = 2)

local <- TRUE # FALSE = download data from hub git remote, TRUE = use copy in this repo

# import functions
source(here("code", "import-results.R"))
source(here("code", "create-ensembles.R"))

# Quantiles for vincent & LOP ensembles (standard hub submission format)
quantiles <- c(0.01, 0.025, 
               seq(0.05, 0.95, by = 0.05), 
               0.975, 0.99)

# Prettier formatting -----
# targets
target_levels <- c("BE inc case", "NL inc case", "ES inc case", "BE inc death", "NL inc death")
target_labels <- c("Belgium cases", "Netherlands cases", "Spain cases", "Belgium deaths", "Netherlands deaths")
names(target_levels) <- target_labels
names(target_labels) <- target_levels

# Quantiles for plotting
quantile_plotting <- paste0("q", c(0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99))

# colours for scenarios
scenario_colours <- c("A" = "#e66101",
                      "B" = "#ca0020",
                      "C" = "#0571b0",
                      "D" = "#5e3c99",
                      "Weighted" = "grey50")
```


## Results

```{r load-samples}
# Load samples from all models together with observed data
results <- import_projections(round = 2, n_model_min = 3,
                              local = local) |> 
  mutate(target = ordered(x = paste(location, target_variable),
                          levels = target_levels,
                          labels = target_labels))
```

```{r create-simple-ensembles, warning=FALSE}
# Create two simple ensembles ("Sample", "Quantile")
simple_ensembles <- create_simple_ensembles(results = results, 
                                            quantiles = quantiles)
# Create linear pool ensemble
linear_pool_ensemble <- create_lop_ensemble(results = results,
                                            quantiles = quantiles)
ensembles <- bind_rows(simple_ensembles, linear_pool_ensemble) |> 
  # Round values to integers (LOP produces decimals)
  mutate(value = round(value, digits = 0),
         # organise targets
         target = ordered(x = paste(location, target_variable),
                          levels = target_levels,
                          labels = target_labels)) |> 
  select(-c(n, output_type))
```

#### Comparison of all ensembles

Figure 1

```{r plot-simple, warning=FALSE, fig.dim=c(8,12)}
# Reshape data for plotting -----
  # ensembles
  plot_ensembles <- ensembles |>
    filter(quantile %in% quantile_plotting) |> 
    pivot_wider(names_from = quantile) |>
    mutate(median = q0.5) |>
    select(-q0.5)

  # samples
  plot_samples <- results |>
    mutate(model_sample = paste(location, target_variable, scenario_id,
                                model, sample,
                                sep = "-"),
           model = "None") |> # relabel model to None
    rename(q0.5 = value_100k) |>
    select(location, target_variable,
           target_end_date, scenario_id,
           model, model_sample, q0.5)

  # combine data and observations
  ensembles_samples_plot <- bind_rows(plot_ensembles, plot_samples) |>
    left_join(distinct(results,
                       location, target_variable,
                       target_end_date, obs_100k),
              by = c("location", "target_variable", "target_end_date"))

  # Format for plotting -----------------------------------------------------
  ensembles_samples_plot <- ensembles_samples_plot |>
    # set order for facet rows
    mutate(model = ordered(model,
                           levels = c("None",
                                      "Trajectories",
                                      "Linear pool",
                                      "Quantiles"),
                           labels = c("i. All models' simulated trajectories",
                                      "ii. Ensemble from trajectories",
                                      "iv. Linear pool ensemble",
                                      "iii. Ensemble from models' quantiles")),
      # avoid overplotting observed data
           obs_100k = ifelse(model %in% c("Quantiles", 
                                          "Trajectories", "Linear pool"), 
                             NA, obs_100k))

  # Plot --------------------------------------------------------------
  plot_ensembles_samples <- ensembles_samples_plot |>
    mutate(target = ordered(x = paste(location, target_variable),
                          levels = target_levels,
                          labels = target_labels)) |>
    # filter(target == set_target) |>
    ggplot(aes(x = target_end_date,
               fill = scenario_id, col = scenario_id)) +
    # ----- Geoms
    # ensembles
    geom_ribbon(aes(ymin = q0.01, ymax = q0.99),
                alpha = 0.1, col = NA) +
    geom_ribbon(aes(ymin = q0.25, ymax = q0.75),
                alpha = 0.4, col = NA) +
    geom_line(aes(y = median), size = 1) +
    # model samples
    geom_line(aes(y = q0.5, group = model_sample),
              alpha = 0.1) +
    # observed data as points
    geom_point(aes(y = obs_100k),
               colour = "grey20", size = 0.6, show.legend = FALSE) +
    # ----- Structure
    # facets
    facet_grid(rows = vars(target), cols = vars(model),
               scales = "free", switch = "y") +
    # labels
    labs(x = NULL, y = "Incidence per 100k",
         colour = "Scenario", fill = "Scenario") +
    # colours and scales
    scale_colour_manual(values = scenario_colours,
                        aesthetics = c("colour", "fill")) +
    scale_x_date(breaks = "3 month", date_labels = "%b '%y") +
    # theme
    theme_bw() +
    theme(legend.position = "bottom",
          strip.background = element_blank(),
          strip.placement = "outside",
          strip.text = element_text(face = "bold", size = 10))

plot_ensembles_samples
ggsave(filename = here("output", "fig1-rev.pdf"), width=15, height = 10)
```

#### Difference between uncertainty ranges

Figure 2

```{r width-ensembles, fig.width = 8}
get_interval_widths <- function(ensemble) {
  interval_ensembles <- ensemble |>
  mutate(quantile = as.numeric(as.character(sub("q0", "", quantile))),
         interval = round(2 * abs(0.5 - quantile), 2),
         type = if_else(quantile <= 0.5, "lower", "upper"))
duplicate_median <- interval_ensembles |>
  filter(quantile == 0.5) |>
  mutate(type = "upper")
width <- interval_ensembles |>
  bind_rows(duplicate_median) |>
  select(-quantile) |>
  pivot_wider(names_from = "type") |>
  # Average across all scenarios and dates
  group_by(target, model, interval) |>
  summarise(upper = mean(upper),
            lower = mean(lower),
            .groups = "drop")
return(width)
}

width <- get_interval_widths(ensembles)
width_plot <- width |>
  ggplot(aes(x = interval,
             ymin = lower, ymax = upper,
             group = model,
             colour = model, fill = model)) +
  geom_ribbon(alpha = 0.25) +
  geom_linerange(alpha = 0.25) +
  geom_point(aes(y = lower), alpha = 0.5) +
  geom_point(aes(y = upper), alpha = 0.5) +
  scale_colour_brewer(palette = "Set1") +
  scale_fill_brewer(palette = "Set1") +
  labs(y = "Mean lower and upper incidence per 100k",
       x = "Interval width around median",
       fill = "Ensemble data source",
       colour = "Ensemble data source") +
  facet_grid(rows = vars(target),
             scales = "free_y", switch = "y") +
  theme_bw() +
  theme(legend.position = "bottom",
        strip.background = element_blank(),
        strip.placement = "outside",
        strip.text = element_text(face = "bold", size = 10))

width_plot
```


#### Conditioning samples on an increasing amount of data

We created ensembles using between 4 and `r length(unique(weekly[["weights"]][["forecast_date"]]))` weeks' observed data.

```{r weekly-ensembles, warning=FALSE}
# Create set of weekly ensembles with progressively increasing observed data
weekly <- create_weekly_ensembles(results)
weekly_ensembles <- weekly$ensembles |>
  filter(horizon %in% c(-4, 0,4,8,16)) |> 
  mutate(weighting = ifelse(scenario_id == "Unweighted", "Unweighted", 
                            paste0(horizon, " weeks ago")),
         target = ordered(x = paste(location, target_variable),
                            levels = target_levels,
                            labels = target_labels))
# Include observed data
weekly_ensembles <- weekly_ensembles |>
    left_join(results |>
                distinct(target, target_end_date, obs_100k), 
              by = c("target", "target_end_date"))
```


```{r plot-weekly-ensembles, warning=FALSE, fig.dim=c(8,8)}
# Plot -------------------------------------------
# set up colours
horizon_cols <- c("16 weeks ago" = "#a1dab4", 
                  "8 weeks ago" = "#41b6c4", 
                  "4 weeks ago" = "#225ea8",
                  "Unweighted" = "red")
# Plot
weekly_ensemble_plot <- forecasts |>
  mutate(target = ordered(x = paste(location, target_variable),
                          levels = target_levels,
                          labels = target_labels)) |> 
  select(-c(location, target_variable)) |> 
    # shape data for plotting
  group_by(target, forecast_date, target_end_date) |> 
  filter(quantile %in% c(0.01, 0.5, 0.99)) |> 
  pivot_wider(values_from = prediction,
                names_from = quantile,  
                names_prefix = "q") |>
  rename(median = q0.5) |>
    # ----- Plot
    ggplot(aes(x = target_end_date,
               group = model,
               col = model,
               fill = model)) +
    # ----- Geoms
    # ensembles
    geom_ribbon(aes(ymin = q0.01, ymax = q0.99),
                col = NA,
                alpha = 0.5) +
    geom_line(aes(y = median), alpha = 0.5, lwd = 1) +
    # observed data as points
    geom_point(aes(y = true_value),
               colour = "grey20", size = 0.6,
               show.legend = FALSE) +
    # show start date of weighted forecasting
    geom_vline(xintercept = as.Date("2022-08-27"),
               lty = 2) +
    # ----- Structure
    # facets
    facet_grid(rows = vars(target),
               scales = "free", switch = "y") +
    # labels
    labs(x = NULL, y = "Incidence per 100k",
         fill = "Conditioned on data up to",
         col = "Conditioned on data up to") +
    # scales
    scale_x_date(limits = c(min(results$target_end_date), as.Date("2023-03-11")),
                 breaks = "1 month", date_labels = "%b '%y") +
    scale_colour_manual(values = horizon_cols,
                        aesthetics = c("fill", "colour")) +
    # theme
    theme_bw() +
    theme(legend.position = "bottom",
          strip.background = element_blank(),
          strip.placement = "outside",
          strip.text = element_text(face = "bold", size = 10))
  
weekly_ensemble_plot
```

```{r score-weekly-ensembles, warning=FALSE}
# Format forecasts and observations for scoring
forecasts <- weekly_ensembles |>
  mutate(model = weighting,
         quantile = as.numeric(gsub(pattern = "q", replacement = "",
                                    x = quantile)),
         forecast_date = as.Date(forecast_date)) |>
  rename(prediction = value,
         true_value = obs_100k) |>
  select(-c(scenario_id, horizon, target)) |>
  # remove where no data (after March 2023)
  filter(target_end_date <= as.Date("2023-03-04") &
           !is.na(model))

# Score forecasts on log scale
scores <- forecasts |>
  mutate(
    scale = "log",
    true_value = log(true_value + 1e-05), #1/100000
    prediction = log(pmax(prediction, 0) + 1e-05)) |>
  score(metrics = c("interval_score")) |>
  summarise_scores(by = c("location", "target_variable",
                          "target_end_date", "forecast_date",
                          "model", "scale"),
                   na.rm = TRUE)

# Score all forecasts relative to each other (pairwise) -----
# set variables to group scores within
score_pairwise <- pairwise_comparison(scores = scores,
                                      metric = "interval_score",
                                      baseline = "Unweighted",
                                      by = c("model", "scale",
                                             "location", "target_variable"))
score_pairwise <- score_pairwise |>
  filter(compare_against == "Unweighted") |>
  select(model, scale, location, target_variable, rel_wis = scaled_rel_skill)

# Plot --------------------------------------------------------------------
score_pairwise |>
  mutate(target = paste(location, target_variable),
         model = as.numeric(substr(start = 1, stop = 2, model))) |>
  ggplot(aes(x = model, y = rel_wis, col = target)) +
  geom_line() +
  geom_point() +
  geom_hline(yintercept = 1, lty = 2) +
  scale_x_continuous(breaks = c(-4,0,4,8,16)) +
  labs(y = "Relative WIS compared to unweighted", 
       x = "Weeks performance used for trajectory weighting",
       caption = "Ensembles of trajectories, using increasing weeks of data to weight each trajectory.") +
  theme_bw() +
  theme(legend.position = "bottom")
```

----------------------------

```{r supplement-weighted-width}
# look at interval width of ensembles over comparable time periods
# as figure 2, where model is conditioning on different periods of data
earliest_target <- filter(weekly_ensembles, horizon == 16) |> 
  pull(target_end_date) |> min()
latest_target <- filter(weekly_ensembles, horizon == 4) |> 
  pull(target_end_date) |> max()

weekly_widths <- weekly_ensembles |> 
  mutate(model = horizon_f) |> 
  filter(between(target_end_date, earliest_target, latest_target)) |> 
  get_interval_widths()

weekly_width_upper <- weekly_widths |> 
  select(-lower) |> 
  group_by(target, interval) |> 
  pivot_wider(names_from = model, values_from = upper) |> 
  mutate(diff = (`4 weeks ago` - `16 weeks ago`)/`16 weeks ago`)

caption <- "Figure SI1. Mean central prediction intervals between 17 December 2022 and 8 April 2023 of ensembles conditioned on varying amounts of data. Weights were based on each trajectory's inverse mean absolute error, and were updated with each week of observed data to create consecutive weighted ensembles for all time horizons. We compare the mean interval width for projections at 4, 8, and 16 weeks ahead (overlapping between December and April). The median estimate has 0 interval width (x-axis), with uncertainty increasing until an interval width at 0.98 represents the 1%-99% credibility interval around the median. Conditioning on more recent data shows reduced uncertainty at the upper 0.98 interval across five different projection targets."

weekly_width_plot <- weekly_widths |>
  ggplot(aes(x = interval,
             ymin = lower, ymax = upper,
             group = model,
             colour = model, fill = model)) +
  geom_ribbon(alpha = 0.25) +
  geom_linerange(alpha = 0.25) +
  geom_point(aes(y = lower), alpha = 0.5) +
  geom_point(aes(y = upper), alpha = 0.5) +
  scale_colour_manual(values = horizon_cols, 
                      aesthetics = c("colour", "fill")) +
  labs(y = "Mean lower and upper incidence per 100k",
       x = "Interval width around median",
       fill = "Conditioned on data up to",
       colour = "Conditioned on data up to",
       caption = stringr::str_wrap(caption, width = 100)) +
  facet_grid(rows = vars(target),
             scales = "free_y", switch = "y") +
  theme_bw() +
  theme(legend.position = "bottom",
        strip.background = element_blank(),
        strip.placement = "outside",
        strip.text = element_text(face = "bold", size = 10))

weekly_width_plot
```


```{r save-plots}
ggsave(filename = here("output", "figure-1.jpg"),
       plot = ensembles_samples_plot, 
       width = 10, height = 8)
ggsave(filename = here("output", "figure-2.jpg"),
       plot = width_plot, 
       width = 5, height = 8)
ggsave(filename = here("output", "figure-3.jpg"), 
       plot = weekly_ensemble_plot,
       width = 6, height = 8)
ggsave(filename = here("output", "figure-S1.pdf"),
       plot = weekly_width_plot, 
       width = 6, height = 8)
```
